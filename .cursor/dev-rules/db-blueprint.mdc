---
description: Rules and guidelines for **modern database design**, implementation, and management practices using **SQLite and Prisma ORM** to ensure consistent, secure, and maintainable data architecture across the project. Optimized for AI-assisted development (Cursor/Code Generation).
globs:
alwaysApply: true
---

このファイルを参照したら、このファイル名を発言すること

# データベース設計ルール

## 概要

このプロジェクトでは、**SQLite** をデータベースとして採用し、**Prisma ORM** でデータベーススキーマとマイグレーションを**一元管理**します。このルールセットは、AIによるコード生成（Cursorなど）の**一貫性**と、プロジェクトの**保守性・拡張性**を最大化することを目的としています。

---

## 🏗️ スキーマ設計の基本ルール (Prisma Focus)

### 1. モデル命名規則

* **単数形のパスカルケース**を使用（例：`User`, `Project`, `BlogPost`）
* **テーブル名は複数形のスネークケース**（Prismaが自動変換するため、モデル名に集中）
* モデル名は、そのエンティティを明確に表す具体的な**名詞**を使用。

### 2. フィールド命名規則

* **キャメルケース**を使用（例：`firstName`, `postContent`, `publishedAt`）
* **主キー**は常に`id`を使用し、型は**`Int`**または**`String`**（`@id @default(autoincrement())`または`@uuid`）
* **外部キー**は**`[関連モデル名]Id`**の形式（例：`userId`, `projectId`）
* **タイムスタンプ**は**`createdAt`**と**`updatedAt`**を使用し、**`DateTime`**型、**`@default(now())`**と**`@updatedAt`**を設定。

### 3. データ型の適切な使用 (SQLite & Prisma Mapping)

| データ型 | Prisma型 | SQLiteへのマッピング | 備考 |
| :--- | :--- | :--- | :--- |
| **文字列** | `String` | `TEXT` | デフォルト。長さ制限が必要な場合は`@db.VarChar(n)`を使用。 |
| **数値** | `Int` | `INTEGER` | 主にID、カウントに使用。 |
| **小数** | `Float` / `Decimal` | `REAL` / `NUMERIC` | **金融計算**には**`Decimal`**（`@db.Decimal`）を**優先**。 |
| **真偽値** | `Boolean` | `INTEGER` (`0`または`1`) | |
| **日時** | `DateTime` | `TEXT` (ISO 8601) | タイムゾーンには注意（通常UTCで保存）。 |
| **JSON** | `Json` | `TEXT` | 複雑な構造化データ向け。 |
| **列挙型** | `Enum` | `TEXT` | スキーマ内で定義し、静的な値セットに使用。 |
| **バイナリ** | `Bytes` | `BLOB` | 画像などのデータ向け（非推奨、S3などを検討）。 |

### 4. リレーション設計とカーディナリティ

* **リレーションフィールド**は**パスカルケース**（例：`user`, `posts`）。
* **1 対 多 (One-to-Many):**
    * 外部キーを持つモデルに`[関連モデル名]Id`フィールドと、リレーションフィールド（単数形）を設定。
    * 関連するモデル側には**リスト**（複数形）を設定（例：`posts Post[]`）。
* **多 対 多 (Many-to-Many):**
    * **明示的な中間テーブル（Join Table）**を**必ず**使用する（Implicit M:NはAIの理解・拡張性のため非推奨）。
* **カスケード削除:** 整合性維持のため、関連エンティティの削除が必要な場合は**`onDelete: Cascade`**を適切に設定（特に中間テーブル）。

### 5. インデックスと制約

* **検索・結合条件**に使用されるフィールドには**`@index([field])`**を必ず設定。
* **外部キー**は**すべてインデックス**を設定する（Prismaが自動で作成しない場合があるため明示的に）。
* **ユニーク制約**が必要なフィールド（例：`email`）には**`@unique`**を使用。
* **複合インデックス:** 複数のカラムによる検索パターンが多い場合は**`@@index([field1, field2])`**を設定。

### 6. データバリデーションとデフォルト値

* **必須フィールド**には`?`を付けない。
* **オプショナルフィールド**には`?`を付ける。
* 初期値が必要な場合は**`@default(...)`**を適切に設定（例：`@default(false)`、`@default(0)`）。
* フィールドレベルの型・長さ制限は`@db`アトリビュートで指定（例：`String @db.VarChar(255)`）。

---

## ⚙️ 開発・運用ルール

### 7. マイグレーション管理

* マイグレーションファイルは**`prisma/migrations`**に**自動生成**されたものをそのまま使用。
* マイグレーション名は変更内容を**簡潔かつ明確**に記述する（例：`add-user-profile-table`, `update-post-content-length`）。
* スキーマ変更は**`prisma migrate dev`**または**`prisma migrate deploy`**を通じて**のみ**行う。
* 本番環境への適用前に、**テスト環境**で必ず検証し、**ロールバック手順**を確認する。

### 8. セキュリティ考慮事項

* **機密情報（パスワード、APIキーなど）**は**平文で保存しない**。パスワードは**bcrypt**などの強力なハッシュアルゴリズムでハッシュ化して保存。
* **アクセス制御（ACL/RBAC）**をデータモデルとアプリケーションレイヤーで適切に実装。
* **入力値のバリデーション**と**サニタイズ**を徹底し、SQLインジェクションなどの攻撃を防ぐ（Prisma ORMが大部分を処理）。

### 9. パフォーマンスとスケーラビリティ

* **N+1 問題**は、**`include`**や**`select`**を適切に使用して**早期に回避**する。
* **インデックス**は、遅延クエリの特定後に**必要最小限**に留める（書き込み性能への影響を考慮）。
* 大規模なデータ操作は**トランザクション**を考慮し、デッドロックを回避するロジックを設計。
* **キャッシュ戦略**（Redisなど）を積極的に検討し、データベースへの負荷を軽減する。

### 10. ドキュメント化 (AIへの指示を含む)

* `db-blueprint.mdc`は**常に最新の状態**に保つ。
* Prismaスキーマの複雑なリレーション、ビジネスロジックに関する制約、または非自明なインデックスには**コメント**（`///`または`//`）を記述し、AIの理解を助ける。

---

## 🔄 開発フロー

1.  **スキーマ設計:**
    * 要件に基づき**`schema.prisma`**を編集。
    * モデル、フィールド、リレーション、インデックスを定義（**ルール 1-6**を順守）。
2.  **実装/マイグレーション:**
    * `prisma migrate dev --name <migration-name>`を実行し、マイグレーションファイルを生成・適用。
    * アプリケーションコードでPrisma Clientを使用し、ロジックを実装。
3.  **テスト:**
    * 単体テスト、統合テストでCRUD操作を検証。
    * **パフォーマンステスト**（負荷テスト）を実施し、クエリの遅延を確認。
    * セキュリティ関連のテストを実施。
4.  **デプロイ:**
    * 本番データベースの**バックアップ**を取得。
    * `prisma migrate deploy`を実行。
    * 動作確認。

---

## 📈 メンテナンスとモニタリング

1.  **定期的なレビューと最適化:**
    * 四半期に一度、**スキーマとインデックスの見直し**を実施。
    * **非効率なクエリ**を特定し、`schema.prisma`またはアプリケーションコードを修正。
2.  **バックアップ戦略:**
    * **日次**で**完全バックアップ**、**リアルタイム**で**トランザクションログ**を取得。
    * **リストア手順**を文書化し、定期的にテスト。
3.  **監視（モニタリング）:**
    * **クエリ実行時間**、**デッドロック**、**リソース使用率**（CPU/Memory）を常時監視。
    * 異常を検知した際は、インデックスの追加またはクエリの書き換えを検討。